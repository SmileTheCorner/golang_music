import { _ as __unplugin_components_0 } from './PanelGrids-15f9a979.js';
import { a$ as ref, a1 as computed, b8 as shallowRef, c5 as useDevToolsClient, cr as useThrottleFn, v as defineComponent, r as resolveComponent, o as openBlock, e as createElementBlock, x as createBaseVNode, z as unref, c as createBlock, q as normalizeClass, y as toDisplayString, l as normalizeStyle, F as Fragment, i as renderList, g as createCommentVNode, aP as onMounted, cs as onVueInstanceUpdate, u as createVNode, h as withCtx, c6 as rootPath, aZ as reactive, _ as __unplugin_components_7, ct as instance } from './index-55dde797.js';
import { a as _sfc_main$2, _ as _sfc_main$3 } from './StateFields.vue_vue_type_script_setup_true_lang-eaba3733.js';
import { a as getInstanceName, c as classify, k as kebabize, i as isFragment, b as isBeingDestroyed, d as getUniqueComponentId, e as getRenderKey, f as getInstanceState, h as getInstanceDetails } from './data-1539e705.js';
import { g, M } from './splitpanes.es-ca653775.js';
import './Icon.vue_vue_type_script_setup_true_lang-5b8e75b9.js';
import './index-ef144caa.js';
import './IconButton.vue_vue_type_script_setup_true_lang-1af9c374.js';

class ComponentFilter {
  filter;
  constructor(filter) {
    this.filter = filter || "";
  }
  /**
   * Check if an instance is qualified.
   *
   * @param {Vue|Vnode} instance
   * @return {Boolean}
   */
  isQualified(instance) {
    const name = getInstanceName(instance);
    return classify(name).toLowerCase().includes(this.filter) || kebabize(name).toLowerCase().includes(this.filter);
  }
}

/* Injected with object hook! */

function getRootElementsFromComponentInstance(instance) {
  if (isFragment(instance))
    return getFragmentRootElements(instance.subTree);
  if (!instance.subTree)
    return [];
  return [instance.subTree.el];
}
function getFragmentRootElements(vnode) {
  if (!vnode.children)
    return [];
  const list = [];
  for (let i = 0, l = vnode.children.length; i < l; i++) {
    const childVnode = vnode.children[i];
    if (childVnode.component)
      list.push(...getRootElementsFromComponentInstance(childVnode.component));
    else if (childVnode.el)
      list.push(childVnode.el);
  }
  return list;
}
function getInstanceOrVnodeRect(instance) {
  const el = instance.subTree.el;
  if (typeof window === "undefined") {
    return;
  }
  if (isFragment(instance))
    return addIframePosition(getFragmentRect(instance.subTree), getElWindow(el));
  else if (el.nodeType === 1)
    return addIframePosition(el.getBoundingClientRect(), getElWindow(el));
  else if (instance.subTree.component)
    return getInstanceOrVnodeRect(instance.subTree.component);
}
function createRect() {
  const rect = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    get width() {
      return rect.right - rect.left;
    },
    get height() {
      return rect.bottom - rect.top;
    }
  };
  return rect;
}
function mergeRects(a, b) {
  if (!a.top || b.top < a.top)
    a.top = b.top;
  if (!a.bottom || b.bottom > a.bottom)
    a.bottom = b.bottom;
  if (!a.left || b.left < a.left)
    a.left = b.left;
  if (!a.right || b.right > a.right)
    a.right = b.right;
  return a;
}
let range;
function getTextRect(node) {
  if (!range)
    range = document.createRange();
  range.selectNode(node);
  return range.getBoundingClientRect();
}
function getFragmentRect(vnode) {
  const rect = createRect();
  if (!vnode.children)
    return rect;
  for (let i = 0, l = vnode.children.length; i < l; i++) {
    const childVnode = vnode.children[i];
    let childRect;
    if (childVnode.component) {
      childRect = getInstanceOrVnodeRect(childVnode.component);
    } else if (childVnode.el) {
      const el = childVnode.el;
      if (el.nodeType === 1 || el.getBoundingClientRect)
        childRect = el.getBoundingClientRect();
      else if (el.nodeType === 3 && el.data.trim())
        childRect = getTextRect(el);
    }
    if (childRect)
      mergeRects(rect, childRect);
  }
  return rect;
}
function getElWindow(el) {
  return el.ownerDocument.defaultView;
}
function addIframePosition(bounds, win) {
  if (win.__VUE_DEVTOOLS_IFRAME__) {
    const rect = mergeRects(createRect(), bounds);
    const iframeBounds = win.__VUE_DEVTOOLS_IFRAME__.getBoundingClientRect();
    rect.top += iframeBounds.top;
    rect.bottom += iframeBounds.top;
    rect.left += iframeBounds.left;
    rect.right += iframeBounds.left;
    if (win.parent)
      return addIframePosition(rect, win.parent);
    return rect;
  }
  return bounds;
}

/* Injected with object hook! */

const InstanceMap = /* @__PURE__ */ new Map();
class ComponentWalker {
  maxDepth;
  recursively;
  componentFilter;
  // Dedupe instances
  // Some instances may be both on a component and on a child abstract/functional component
  captureIds;
  constructor(maxDepth, filter, recursively) {
    this.maxDepth = maxDepth;
    this.recursively = recursively;
    this.componentFilter = new ComponentFilter(filter);
    this.captureIds = /* @__PURE__ */ new Map();
  }
  getComponentTree(instance) {
    this.captureIds = /* @__PURE__ */ new Map();
    return this.findQualifiedChildren(instance, 0);
  }
  getComponentParents(instance) {
    this.captureIds = /* @__PURE__ */ new Map();
    const parents = [];
    this.captureId(instance);
    let parent = instance;
    while (parent = parent.parent) {
      this.captureId(parent);
      parents.push(parent);
    }
    return parents;
  }
  /**
   * Find qualified children from a single instance.
   * If the instance itself is qualified, just return itself.
   * This is ok because [].concat works in both cases.
   *
   * @param {Vue|Vnode} instance
   * @return {Vue|Array}
   */
  async findQualifiedChildren(instance, depth) {
    if (this.componentFilter.isQualified(instance) && !instance.type.devtools?.hide) {
      return [await this.capture(instance, [], depth)];
    } else if (instance.subTree) {
      const list = this.isKeepAlive(instance) ? this.getKeepAliveCachedInstances(instance) : this.getInternalInstanceChildren(instance.subTree);
      return this.findQualifiedChildrenFromList(list, depth);
    } else {
      return [];
    }
  }
  /**
   * Iterate through an array of instances and flatten it into
   * an array of qualified instances. This is a depth-first
   * traversal - e.g. if an instance is not matched, we will
   * recursively go deeper until a qualified child is found.
   *
   * @param {Array} instances
   * @return {Array}
   */
  async findQualifiedChildrenFromList(instances, depth) {
    instances = instances.filter((child) => !isBeingDestroyed(child));
    if (!this.componentFilter.filter)
      return Promise.all(instances.map((child, index, list) => this.capture(child, list, depth)));
    else
      return Array.prototype.concat.apply([], await Promise.all(instances.map((i) => this.findQualifiedChildren(i, depth))));
  }
  /**
   * Get children from a component instance.
   */
  getInternalInstanceChildren(subTree, suspense = null) {
    const list = [];
    if (subTree) {
      if (subTree.component) {
        !suspense ? list.push(subTree.component) : list.push({ ...subTree.component, suspense });
      } else if (subTree.suspense) {
        const suspenseKey = !subTree.suspense.isInFallback ? "suspense default" : "suspense fallback";
        list.push(...this.getInternalInstanceChildren(subTree.suspense.activeBranch, { ...subTree.suspense, suspenseKey }));
      } else if (Array.isArray(subTree.children)) {
        subTree.children.forEach((childSubTree) => {
          if (childSubTree?.component)
            !suspense ? list.push(childSubTree.component) : list.push({ ...childSubTree.component, suspense });
          else
            list.push(...this.getInternalInstanceChildren(childSubTree, suspense));
        });
      }
    }
    return list.filter((child) => !isBeingDestroyed(child));
  }
  captureId(instance) {
    if (!instance)
      return null;
    const id = getUniqueComponentId(instance);
    if (this.captureIds.has(id))
      return null;
    else
      this.captureIds.set(id, void 0);
    return id;
  }
  /**
   * Capture the meta information of an instance. (recursive)
   *
   * @param {Vue} instance
   * @return {Object}
   */
  async capture(instance, list, depth) {
    if (!instance)
      return null;
    const id = this.captureId(instance);
    const name = getInstanceName(instance);
    const children = this.getInternalInstanceChildren(instance.subTree).filter((child) => !isBeingDestroyed(child));
    const parents = this.getComponentParents(instance) || [];
    const inactive = !!instance.isDeactivated || parents.some((parent) => parent.isDeactivated);
    const treeNode = {
      uid: instance.uid,
      id,
      name,
      renderKey: getRenderKey(instance.vnode ? instance.vnode.key : null),
      inactive,
      hasChildren: !!children.length,
      children: [],
      isFragment: isFragment(instance),
      // TODO: functional components, suspense
      tags: [],
      autoOpen: this.recursively,
      instance: null
    };
    const uids = [];
    if (depth < this.maxDepth || instance.type.__isKeepAlive || parents.some((parent) => parent.type.__isKeepAlive)) {
      treeNode.children = await Promise.all(children.map((child, index, list2) => this.capture(child, list2, depth + 1)).filter(Boolean));
      uids.push(...treeNode.children.map((child) => child.uid));
    }
    if (this.isKeepAlive(instance)) {
      const cachedComponents = this.getKeepAliveCachedInstances(instance);
      for (const cachedChild of cachedComponents) {
        const node = await this.capture({ ...cachedChild, isDeactivated: true }, [], depth + 1);
        const uid = node.uid;
        if (node && !uids.includes(uid))
          treeNode.children.push(node);
      }
    }
    const rootElements = getRootElementsFromComponentInstance(instance);
    const firstElement = rootElements[0];
    if (firstElement?.parentElement) {
      const parentInstance = instance.parent;
      const parentRootElements = parentInstance ? getRootElementsFromComponentInstance(parentInstance) : [];
      let el = firstElement;
      const indexList = [];
      do {
        indexList.push(Array.from(el.parentElement.childNodes).indexOf(el));
        el = el.parentElement;
      } while (el.parentElement && parentRootElements.length && !parentRootElements.includes(el));
      treeNode.domOrder = indexList.reverse();
    } else {
      treeNode.domOrder = [-1];
    }
    InstanceMap.set(treeNode.id, getInstanceState(instance));
    treeNode.instance = instance;
    return treeNode;
  }
  isKeepAlive(instance) {
    return instance.type.__isKeepAlive && instance.__v_cache;
  }
  getKeepAliveCachedInstances(instance) {
    return Array.from(instance.__v_cache.values()).map((vnode) => vnode.component).filter(Boolean);
  }
}

/* Injected with object hook! */

const selected = ref("vue-devtools:root");
const selectedComponentName = ref("");
const selectedComponentNode = ref();
const selectedComponentNodeFilePath = computed(() => selectedComponentNode.value?.instance ? getInstanceDetails(selectedComponentNode.value.instance)?.file : null);
const expandedMap = ref({
  "vue-devtools:root": true
});
const selectedComponent = ref();
const selectedComponentState = shallowRef([]);
function useComponent(instance) {
  function select(data) {
    selected.value = data.id;
    selectedComponentName.value = data.name;
    selectedComponentState.value = InstanceMap.get(data.id);
    selectedComponentNode.value = data;
  }
  function toggleExpand(id) {
    expandedMap.value[id] = !expandedMap.value[id];
  }
  const isSelected = computed(() => selected.value === instance.id);
  const isExpanded = computed(() => expandedMap.value[instance.id]);
  return { isSelected, select, isExpanded, toggleExpand };
}
function useHighlightComponent(node) {
  const client = useDevToolsClient();
  const highlight = useThrottleFn(() => {
    const instance = node.instance;
    const bounds = getInstanceOrVnodeRect(instance);
    const name = getInstanceName(instance);
    client.value?.componentInspector.highlight(name, bounds);
  }, 300);
  const unhighlight = () => {
    client.value?.componentInspector.unHighlight();
  };
  return {
    highlight,
    unhighlight
  };
}
scrollToComponent.timer = null;
function scrollToComponent() {
  if (scrollToComponent.timer)
    clearTimeout(scrollToComponent.timer);
  const client = useDevToolsClient();
  const { highlight, unhighlight } = useHighlightComponent(selectedComponentNode.value);
  const instance = selectedComponentNode.value.instance;
  const [el] = getRootElementsFromComponentInstance(instance);
  if (typeof el.scrollIntoView === "function") {
    el.scrollIntoView({
      behavior: "smooth"
    });
  } else {
    const _bounds = getInstanceOrVnodeRect(instance);
    client.value.componentInspector.scrollToComponent(_bounds);
  }
  scrollToComponent.timer = setTimeout(() => {
    highlight();
    scrollToComponent.timer = setTimeout(() => {
      unhighlight();
      scrollToComponent.timer = null;
    }, 1500);
  }, 1200);
}

/* Injected with object hook! */

const _hoisted_1$1 = {
  key: 1,
  "inline-block": "",
  "h-6": "",
  "w-6": ""
};
const _hoisted_2$1 = { key: 0 };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "ComponentTreeNode",
  props: {
    data: {},
    depth: { default: 0 }
  },
  setup(__props) {
    const props = __props;
    const { isSelected, select, isExpanded, toggleExpand } = useComponent(props.data);
    const { highlight, unhighlight } = useHighlightComponent(props.data);
    return (_ctx, _cache) => {
      const _component_VDExpandIcon = _sfc_main$2;
      const _component_ComponentTreeNode = resolveComponent("ComponentTreeNode", true);
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", {
          style: normalizeStyle({
            paddingLeft: `${_ctx.depth * 15 + 4}px`
          }),
          "vue-block": "",
          class: normalizeClass([unref(isSelected) ? "vue-block-active" : "vue-block-hover"]),
          onClick: _cache[1] || (_cache[1] = ($event) => unref(select)(_ctx.data)),
          onMouseover: _cache[2] || (_cache[2] = //@ts-ignore
          (...args) => unref(highlight) && unref(highlight)(...args)),
          onMouseleave: _cache[3] || (_cache[3] = //@ts-ignore
          (...args) => unref(unhighlight) && unref(unhighlight)(...args))
        }, [
          createBaseVNode("h3", {
            "vue-block-title": "",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.data.hasChildren ? unref(toggleExpand)(_ctx.data.id) : () => {
            })
          }, [
            _ctx.data.hasChildren ? (openBlock(), createBlock(_component_VDExpandIcon, {
              key: 0,
              value: unref(isExpanded)
            }, null, 8, ["value"])) : (openBlock(), createElementBlock("i", _hoisted_1$1)),
            createBaseVNode("span", {
              class: normalizeClass([
                unref(isSelected) ? "vue-tag-symbol-active" : "vue-tag-symbol"
              ])
            }, "<", 2),
            createBaseVNode("span", {
              class: normalizeClass([unref(isSelected) && "text-white"])
            }, toDisplayString(_ctx.data.name), 3),
            createBaseVNode("span", {
              class: normalizeClass([
                unref(isSelected) ? "vue-tag-symbol-active" : "vue-tag-symbol"
              ])
            }, ">", 2)
          ])
        ], 38),
        unref(isExpanded) && _ctx.data.hasChildren ? (openBlock(), createElementBlock("div", _hoisted_2$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data.children, (item) => {
            return openBlock(), createBlock(_component_ComponentTreeNode, {
              key: item.id,
              data: item,
              depth: _ctx.depth + 1
            }, null, 8, ["data", "depth"]);
          }), 128))
        ])) : createCommentVNode("", true)
      ], 64);
    };
  }
});

/* Injected with object hook! */

const _hoisted_1 = {
  "h-screen": "",
  "n-panel-grids": ""
};
const _hoisted_2 = {
  "h-screen": "",
  "select-none": "",
  "overflow-scroll": "",
  "p-2": "",
  class: "no-scrollbar"
};
const _hoisted_3 = {
  key: 0,
  border: "b base",
  flex: "",
  "justify-between": "",
  "px-4": "",
  "py-2": ""
};
const _hoisted_4 = {
  key: 0,
  "text-sm": "",
  "text-primary": "",
  op90: ""
};
const _hoisted_5 = { flex: "" };
const _hoisted_6 = /* @__PURE__ */ createBaseVNode("p", {
  "text-xs": "",
  "op-50": ""
}, " Scroll to component ", -1);
const _hoisted_7 = {
  key: 0,
  "pl-2": ""
};
const _hoisted_8 = {
  "text-xs": "",
  "op-50": ""
};
const _hoisted_9 = {
  key: 1,
  "h-screen": "",
  "select-none": "",
  "overflow-scroll": "",
  "p-2": "",
  class: "no-scrollbar"
};
const _hoisted_10 = /* @__PURE__ */ createBaseVNode("h1", {
  "text-sm": "",
  italic: "",
  op50: ""
}, " No Data ", -1);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "components",
  setup(__props) {
    const componentTree = ref([]);
    function normalizeComponentState(value, type) {
      if (type === "Reactive")
        return reactive(value);
      else if (type === "Computed")
        return computed(() => value);
      else if (type === "Ref")
        return ref(value);
      else
        return value;
    }
    const normalizedComponentState = computed(() => {
      const list = [];
      selectedComponentState.value.forEach((item) => {
        if (list.some((i) => i.key === item.type)) {
          const index = list.findIndex((i) => i.key === item.type);
          list[index].value = {
            ...list[index].value,
            [item.key]: normalizeComponentState(item.value, item.objectType)
          };
        } else {
          list.push({
            key: item.type,
            value: {
              [item.key]: normalizeComponentState(item.value, item.objectType)
            }
          });
        }
      });
      return list;
    });
    function init() {
      const walker = new ComponentWalker(500, null, true);
      selectedComponent.value = instance.value;
      selectedComponentState.value = getInstanceState(instance.value);
      walker.getComponentTree(instance.value).then((res) => {
        componentTree.value = res;
        selectedComponentName.value = res?.[0]?.name ?? "";
        selectedComponentNode.value = res?.[0];
      });
    }
    onMounted(() => {
      onVueInstanceUpdate((v) => {
        if (v) {
          init();
          selected.value = "vue-devtools:root";
        }
      });
    });
    function openInEditor() {
      const client = useDevToolsClient();
      client.value.openInEditor(selectedComponentNodeFilePath.value);
    }
    return (_ctx, _cache) => {
      const _component_ComponentTreeNode = _sfc_main$1;
      const _component_VTooltip = resolveComponent("VTooltip");
      const _component_StateFields = _sfc_main$3;
      const _component_VDCard = __unplugin_components_7;
      const _component_VDPanelGrids = __unplugin_components_0;
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createVNode(unref(M), null, {
          default: withCtx(() => [
            createVNode(unref(g), { border: "r base" }, {
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_2, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(componentTree), (item) => {
                    return openBlock(), createBlock(_component_ComponentTreeNode, {
                      key: item.id,
                      data: item
                    }, null, 8, ["data"]);
                  }), 128))
                ])
              ]),
              _: 1
            }),
            createVNode(unref(g), null, {
              default: withCtx(() => [
                unref(normalizedComponentState).length ? (openBlock(), createElementBlock("div", _hoisted_3, [
                  unref(selectedComponentName) ? (openBlock(), createElementBlock("span", _hoisted_4, "<" + toDisplayString(unref(selectedComponentName)) + ">", 1)) : createCommentVNode("", true),
                  createBaseVNode("p", _hoisted_5, [
                    createBaseVNode("span", null, [
                      createVNode(_component_VTooltip, { placement: "bottom" }, {
                        popper: withCtx(() => [
                          _hoisted_6
                        ]),
                        default: withCtx(() => [
                          createBaseVNode("i", {
                            "gg:scroll-h": "",
                            "cursor-pointer": "",
                            "text-xl": "",
                            op70: "",
                            hover: "op100",
                            onClick: _cache[0] || (_cache[0] = //@ts-ignore
                            (...args) => unref(scrollToComponent) && unref(scrollToComponent)(...args))
                          })
                        ]),
                        _: 1
                      })
                    ]),
                    unref(selectedComponentNodeFilePath) ? (openBlock(), createElementBlock("span", _hoisted_7, [
                      createVNode(_component_VTooltip, { placement: "bottom" }, {
                        popper: withCtx(() => [
                          createBaseVNode("p", _hoisted_8, " Open " + toDisplayString(unref(selectedComponentNodeFilePath).replace(unref(rootPath), "")) + " in editor ", 1)
                        ]),
                        default: withCtx(() => [
                          createBaseVNode("i", {
                            "carbon-launch": "",
                            "cursor-pointer": "",
                            "text-sm": "",
                            op70: "",
                            hover: "op100",
                            onClick: openInEditor
                          })
                        ]),
                        _: 1
                      })
                    ])) : createCommentVNode("", true)
                  ])
                ])) : createCommentVNode("", true),
                unref(normalizedComponentState).length ? (openBlock(), createElementBlock("div", _hoisted_9, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(unref(normalizedComponentState), (item, index) => {
                    return openBlock(), createBlock(_component_StateFields, {
                      id: index,
                      key: item.key,
                      data: item
                    }, null, 8, ["id", "data"]);
                  }), 128))
                ])) : (openBlock(), createBlock(_component_VDPanelGrids, {
                  key: 2,
                  px5: ""
                }, {
                  default: withCtx(() => [
                    createVNode(_component_VDCard, {
                      flex: "~ col gap2",
                      "min-w-30": "",
                      "items-center": "",
                      p3: ""
                    }, {
                      default: withCtx(() => [
                        _hoisted_10
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }))
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]);
    };
  }
});

/* Injected with object hook! */

/* Injected with object hook! */

export { _sfc_main as default };
