import { F as Fragment } from './index-55dde797.js';

function isBeingDestroyed(instance) {
  return instance._isBeingDestroyed || instance.isUnmounted;
}
function isFragment(instance) {
  return Fragment === instance.subTree?.type;
}
function getInstanceName(instance) {
  const name = getComponentTypeName(instance.type || {});
  if (name)
    return name;
  if (instance.root === instance)
    return "Root";
  for (const key in instance.parent?.type?.components) {
    if (instance.parent.type.components[key] === instance.type)
      return saveComponentName(instance, key);
  }
  for (const key in instance.appContext?.components) {
    if (instance.appContext.components[key] === instance.type)
      return saveComponentName(instance, key);
  }
  const fileName = getComponentFileName(instance.type || {});
  if (fileName)
    return fileName;
  return "Anonymous Component";
}
function saveComponentName(instance, key) {
  return key;
}
function getComponentTypeName(options) {
  return options.name || options._componentTag || options.__vdevtools_guessedName || options.__name;
}
function getComponentFileName(options) {
  const file = options.__file;
  if (file) {
    const filename = options.__file?.match(/\/?([^/]+?)(\.[^/.]+)?$/)?.[1];
    return filename ?? file;
  }
}
function getUniqueComponentId(instance) {
  const appId = "vue-devtools";
  const instanceId = instance === instance.root ? "root" : instance.uid;
  return `${appId}:${instanceId}`;
}
function getRenderKey(value) {
  if (value == null)
    return null;
  const type = typeof value;
  if (type === "number")
    return value;
  else if (type === "string")
    return `'${value}'`;
  else if (Array.isArray(value))
    return "Array";
  else
    return "Object";
}
function cached(fn) {
  const cache = /* @__PURE__ */ Object.create(null);
  return function cachedFn(str) {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}
function toUpper(_, c) {
  return c ? c.toUpperCase() : "";
}
const camelizeRE = /-(\w)/g;
const camelize = cached((str) => {
  return str && str.replace(camelizeRE, toUpper);
});
const kebabizeRE = /([a-z0-9])([A-Z])/g;
const kebabize = cached((str) => {
  return str && str.replace(kebabizeRE, (_, lowerCaseCharacter, upperCaseLetter) => {
    return `${lowerCaseCharacter}-${upperCaseLetter}`;
  }).toLowerCase();
});
function returnError(cb) {
  try {
    return cb();
  } catch (e) {
    return e;
  }
}
const classifyRE = /(?:^|[-_/])(\w)/g;
const classify = cached((str) => {
  return str && `${str}`.replace(classifyRE, toUpper);
});

/* Injected with object hook! */

const vueBuiltins = [
  "nextTick",
  "defineComponent",
  "defineAsyncComponent",
  "defineCustomElement",
  "ref",
  "computed",
  "reactive",
  "readonly",
  "watchEffect",
  "watchPostEffect",
  "watchSyncEffect",
  "watch",
  "isRef",
  "unref",
  "toRef",
  "toRefs",
  "isProxy",
  "isReactive",
  "isReadonly",
  "shallowRef",
  "triggerRef",
  "customRef",
  "shallowReactive",
  "shallowReadonly",
  "toRaw",
  "markRaw",
  "effectScope",
  "getCurrentScope",
  "onScopeDispose",
  "onMounted",
  "onUpdated",
  "onUnmounted",
  "onBeforeMount",
  "onBeforeUpdate",
  "onBeforeUnmount",
  "onErrorCaptured",
  "onRenderTracked",
  "onRenderTriggered",
  "onActivated",
  "onDeactivated",
  "onServerPrefetch",
  "provide",
  "inject",
  "h",
  "mergeProps",
  "cloneVNode",
  "isVNode",
  "resolveComponent",
  "resolveDirective",
  "withDirectives",
  "withModifiers"
];
function getInstanceDetails(instance) {
  return {
    id: getUniqueComponentId(instance),
    name: getInstanceName(instance),
    file: instance?.type?.__file,
    state: getInstanceState(instance)
  };
}
function getInstanceState(instance) {
  const mergedType = resolveMergedOptions(instance);
  return processProps(instance).concat(
    processState(instance),
    processSetupState(instance),
    processComputed(instance, mergedType),
    processAttrs(instance),
    processProvide(instance),
    processInject(instance, mergedType),
    processRefs(instance),
    processEventListeners(instance)
  );
}
function processProps(instance) {
  const propsData = [];
  const propDefinitions = instance.type.props;
  for (let key in instance.props) {
    const propDefinition = propDefinitions ? propDefinitions[key] : null;
    key = camelize(key);
    propsData.push({
      type: "props",
      key,
      value: returnError(() => instance.props[key]),
      meta: propDefinition ? {
        type: propDefinition.type ? getPropType(propDefinition.type) : "any",
        required: !!propDefinition.required,
        ...propDefinition.default != null ? { default: propDefinition.default.toString() } : {}
      } : {
        type: "invalid"
      },
      editable: false
    });
  }
  return propsData;
}
const fnTypeRE = /^(?:function|class) (\w+)/;
function getPropType(type) {
  if (Array.isArray(type))
    return type.map((t) => getPropType(t)).join(" or ");
  if (type == null)
    return "null";
  const match = type.toString().match(fnTypeRE);
  return typeof type === "function" ? match && match[1] || "any" : "any";
}
function processState(instance) {
  const type = instance.type;
  const props = type.props;
  const getters = type.vuex && type.vuex.getters;
  const computedDefs = type.computed;
  const data = {
    ...instance.data,
    ...instance.renderContext
  };
  return Object.keys(data).filter((key) => !(props && key in props) && !(getters && key in getters) && !(computedDefs && key in computedDefs)).map((key) => ({
    key,
    type: "data",
    value: returnError(() => data[key]),
    editable: true
  }));
}
function processSetupState(instance) {
  const raw = instance.devtoolsRawSetupState || {};
  return Object.keys(instance.setupState).filter((key) => !vueBuiltins.includes(key) && key.split(/(?=[A-Z])/)[0] !== "use").map((key) => {
    const value = returnError(() => toRaw(instance.setupState[key]));
    const rawData = raw[key];
    let result;
    let isOther = typeof value === "function" || typeof value?.render === "function" || typeof value?.__asyncLoader === "function";
    if (rawData) {
      const info = getSetupStateInfo(rawData);
      const objectType = info.computed ? "Computed" : info.ref ? "Ref" : info.reactive ? "Reactive" : null;
      const isState = info.ref || info.computed || info.reactive;
      const raw2 = rawData.effect?.raw?.toString() || rawData.effect?.fn?.toString();
      if (objectType)
        isOther = false;
      result = {
        ...objectType ? { objectType } : {},
        ...raw2 ? { raw: raw2 } : {},
        editable: isState && !info.readonly
      };
    }
    const type = isOther ? "setup (other)" : "setup";
    return {
      key,
      value,
      type,
      ...result
    };
  });
}
function isRef(raw) {
  return !!raw.__v_isRef;
}
function isComputed(raw) {
  return isRef(raw) && !!raw.effect;
}
function isReactive(raw) {
  return !!raw.__v_isReactive;
}
function isReadOnly(raw) {
  return !!raw.__v_isReadonly;
}
function toRaw(value) {
  if (value?.__v_raw)
    return value.__v_raw;
  return value;
}
function getSetupStateInfo(raw) {
  return {
    ref: isRef(raw),
    computed: isComputed(raw),
    reactive: isReactive(raw),
    readonly: isReadOnly(raw)
  };
}
function processComputed(instance, mergedType) {
  const type = mergedType;
  const computed = [];
  const defs = type.computed || {};
  for (const key in defs) {
    const def = defs[key];
    const type2 = typeof def === "function" && def.vuex ? "vuex bindings" : "computed";
    computed.push({
      type: type2,
      key,
      value: returnError(() => instance.proxy[key]),
      editable: typeof def.set === "function"
    });
  }
  return computed;
}
function processAttrs(instance) {
  return Object.keys(instance.attrs).map((key) => ({
    type: "attrs",
    key,
    value: returnError(() => instance.attrs[key])
  }));
}
function processProvide(instance) {
  return Reflect.ownKeys(instance.provides).map((key) => ({
    type: "provided",
    key: key.toString(),
    value: returnError(() => instance.provides[key])
  }));
}
function processInject(instance, mergedType) {
  if (!mergedType?.inject)
    return [];
  let keys = [];
  let defaultValue;
  if (Array.isArray(mergedType.inject)) {
    keys = mergedType.inject.map((key) => ({
      key,
      originalKey: key
    }));
  } else {
    keys = Reflect.ownKeys(mergedType.inject).map((key) => {
      const value = mergedType.inject[key];
      let originalKey;
      if (typeof value === "string" || typeof value === "symbol") {
        originalKey = value;
      } else {
        originalKey = value.from;
        defaultValue = value.default;
      }
      return {
        key,
        originalKey
      };
    });
  }
  return keys.map(({ key, originalKey }) => ({
    type: "injected",
    key: originalKey && key !== originalKey ? `${originalKey.toString()} ➞ ${key.toString()}` : key.toString(),
    // eslint-disable-next-line no-prototype-builtins
    value: returnError(() => instance.ctx.hasOwnProperty(key) ? instance.ctx[key] : instance.provides.hasOwnProperty(originalKey) ? instance.provides[originalKey] : defaultValue)
  }));
}
function processRefs(instance) {
  return Object.keys(instance.refs).map((key) => ({
    type: "refs",
    key,
    value: returnError(() => instance.refs[key])
  }));
}
function processEventListeners(instance) {
  const emitsDefinition = instance.type.emits;
  const declaredEmits = Array.isArray(emitsDefinition) ? emitsDefinition : Object.keys(emitsDefinition ?? {});
  const keys = Object.keys(instance.vnode.props ?? {});
  const result = [];
  for (const key of keys) {
    const [prefix, ...eventNameParts] = key.split(/(?=[A-Z])/);
    if (prefix === "on") {
      const eventName = eventNameParts.join("-").toLowerCase();
      const isDeclared = declaredEmits.includes(eventName);
      result.push({
        type: "event listeners",
        key: eventName,
        value: {
          _custom: {
            display: isDeclared ? "✅ Declared" : "⚠️ Not declared",
            tooltip: !isDeclared ? `The event <code>${eventName}</code> is not declared in the <code>emits</code> option. It will leak into the component's attributes (<code>$attrs</code>).` : null
          }
        }
      });
    }
  }
  return result;
}
function resolveMergedOptions(instance) {
  const raw = instance.type;
  const { mixins, extends: extendsOptions } = raw;
  const globalMixins = instance.appContext.mixins;
  if (!globalMixins.length && !mixins && !extendsOptions)
    return raw;
  const options = {};
  globalMixins.forEach((m) => mergeOptions(options, m));
  mergeOptions(options, raw);
  return options;
}
function mergeOptions(to, from, instance) {
  if (typeof from === "function")
    from = from.options;
  if (!from)
    return to;
  const { mixins, extends: extendsOptions } = from;
  extendsOptions && mergeOptions(to, extendsOptions);
  mixins && mixins.forEach(
    (m) => mergeOptions(to, m)
  );
  for (const key of ["computed", "inject"]) {
    if (Object.prototype.hasOwnProperty.call(from, key)) {
      if (!to[key])
        to[key] = from[key];
      else
        Object.assign(to[key], from[key]);
    }
  }
  return to;
}

/* Injected with object hook! */

export { getInstanceName as a, isBeingDestroyed as b, classify as c, getUniqueComponentId as d, getRenderKey as e, getInstanceState as f, getSetupStateInfo as g, getInstanceDetails as h, isFragment as i, kebabize as k, toRaw as t };
